### 偏向锁
偏向锁相比轻量级锁更纯粹 干脆就把整个同步都消除掉 不需要再进行CAS操作了 它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取 这种情况下 我们可以对轻量级锁进一步优化

偏向锁实际上就是专门为单个线程而生的 当某个线程第一次获得锁时 如果接下来都没有其他线程获取此锁 那么持有锁的线程将不再需要进行同步操作

可以从之前的Mark Word结构中看到 偏向锁也会通过CAS操作记录线程的ID 如果一直都是同一个线程获取此锁 那么完全没有必要在进行额外的CAS操作
当然 如果有其他线程来抢了 那么偏向锁会根据当前状态 决定是否要恢复到未锁定或是膨胀为轻量级锁。

如果我们需要使用偏向锁 可以添加-XX:+UseBiased参数来开启

所以，最终的锁等级为: 未锁定 < 偏向锁 < 轻量级锁 < 重量级锁

值得注意的是 如果对象通过调用hashCode()方法计算过对象的一致性哈希值 那么它是不支持偏向锁的 会直接进入到轻量级锁状态 因为Hash是需要被保存的
而偏向锁的Mark Word数据结构 无法保存Hash值 如果对象已经是偏向锁状态 再去调用hashCode()方法 那么会直接将锁升级为重量级锁 并将哈希值存放在monitor(有预留位置保存)中

<img src="https://fast.itbaima.net/2023/03/06/1fQs3C5BKZgamc9.png"/>

### 锁消除和锁粗化
锁消除和锁粗化都是在运行时的一些优化方案 比如我们某段代码虽然加了锁 但是在运行时根本不可能出现各个线程之间资源争夺的情况 这种情况下 完全不需要任何加锁机制
所以锁会被消除 锁粗化则是我们代码中频繁地出现互斥同步操作 比如在一个循环内部加锁 这样明显是非常消耗性能的 所以虚拟机一旦检测到这种操作 会将整个同步范围进行扩展